---
layout: post
title:  "Unity引擎与C#脚本简介"
date:   2018-01-30 10:28:01 +0800
categories: jekyll update
---
今天我们来简单地聊聊游戏开发。这篇文章主要基于Unity游戏开发引擎，主要会讲到一些基本的原理知识：第一部分讲简单讲讲游戏开发的原理，接下来一部分会聊聊Unity的C#游戏脚本。
## 1. Unity编辑器基础
其实从原理上讲，游戏开发就是将一系列变动的场景呈现在玩家面前，并根据玩家的输入修改游戏画面。游戏画面是通过调用目标操作系统上的图像API来绘制的。比较知名的图形API有Windows上的DirectX，*nix系统、macOS和iOS等系统上用到的OpenGL，以及Android用到的Vulkan等。一般来讲，底层的图像API只能进行最基本的三角形绘制。但是，因为是通过计算机的GPU有并行计算的优势，在短短六十分之一秒的时间内，也可以绘制出成千上万个三角形。这么多小三角形堆叠起来的时候，看起来的视觉效果也和真实场景差别也不大了。

<p align="center">
<img src="/assets/image/2018-1-30-unity_engine_and_csharp_script/pic_1.png">
</p>

<h5 align="center">
图一：古墓丽影劳拉变化图
</h5>

现代的游戏引擎一般都会把游戏人物的“建模”工作交给第三方，引擎本身只负责游戏场景和人物的绘制以及内部逻辑。第三方建模软件通过模拟人物的真实3D外观来将虚拟人物表面“三角形化”，还需要带上游戏人物在作出不同动作的时候的外观数据，最后生成游戏引擎可以读取的文件格式，这个过程就是所谓的3D建模。
<p align="center">
<img src="/assets/image/2018-1-30-unity_engine_and_csharp_script/pic_2.png">
</p>

<h5 align="center">
图二：绘制流程
</h5>

3D模型制作完成后，就交给游戏引擎来绘制，这个过程一般称作“着色”（Shading）。着色过程的核心是一个叫做“着色器(Shader)”的GPU程序。GPU通过输入一些参数信息，然后执行着色器程序就能生成最终的游戏图像。GPU需要的参数信息主要有两种：一是纹理，二是材质。纹理是指一个模型的表面，可以理解成一件衣服平铺起来的样子。如果是一个三维物体，其表面的纹理可以想象成是把它的表面拆开，然后压扁后的样子。什么是材质呢？材质（Material)从字面上理解的话就是材料，比如木头和大理石，看起来就是不一样的效果。同样的纹理，用不一样的材质来绘制，会得到不一样的效果图。因为材质有一些关键的参数，会影响着色器的绘制效果。

比较重要的一个参数是反射率(Albedo)。
光滑材质的反射率比较高，看起来就会亮一些。在自然白光的照射下，这样的材质看起来就会偏白，如果沿着光照方向看过去，会出现光斑效果（太阳光照射下的湖面看起来会有一种很耀眼的效果）。粗糙材质的反射率比较低，看起来比较柔和。典型的高反射率材质有光滑的金属表面等，典型的低反射率材质有布料、地面等。在3D场景中，反射率高的物体受周围物体的影响更大。譬如，一个平静的湖面会倒映出地面的建筑物。因此，高反射率的材质通常需要更多的绘制步骤。
<p align="center">
<img src="/assets/image/2018-1-30-unity_engine_and_csharp_script/pic_3.png">
</p>

<h5 align="center">
图三：一个金属球体在场景中的效果图
</h5>

材质的另一个重要参数是法向图(Normal Map)。
法向就是物体表面的方向。法向图表示的是材质的表面细节，比如凹槽、斑点、凸起或者空洞等，法向图通常以纹理图来表示。然而不同于一般的纹理图，法向图的每个像素点称作“纹素（texel）”，它表示的是纹理在此位置处的光照反射方向，纹素的RGB分量分别对应反射方向的XYZ分量。
<p align="center">
<img src="/assets/image/2018-1-30-unity_engine_and_csharp_script/pic_4.png">
</p>

<h5 align="center">
图四：法向图示例
</h5>

一个3D模型的表面纹理被分割成一个个小三角形，而法向图就表示此表面的每个像素点位置的光照反射方向。方向不同的三角形绘制出来和周围的三角形看起来颜色是不同的，从而产生了视觉上的凸起/凹陷效果。这种物体的表面细节，如果在3D建模阶段通过修改模型外观的方式来实现的话，会增加很多物体表面的细小的绘制操作。通过材质的法向图来实现，将物体“表面”和物体的实际皮肤剥离开了，可以实现同一个人物穿上不同衣服的效果。
<p align="center">
<img src="/assets/image/2018-1-30-unity_engine_and_csharp_script/pic_5.png">
</p>

<h5 align="center">
图五：右边的物体采用左边的法向图来绘制，注意看凸起位置的颜色。
</h5>

##  2. C#脚本语言
### 2.1 为什么需要脚本？
长久以来，游戏引擎开发都采用底层语言如C++来开发，这对于游戏上层开发来说，并不友好。很难想象如果使用一款引擎修改某个人物的动作，还需要直接调用C++底层的接口。这样既不安全，也不方便。因此，一般引擎从设计之初就会把封装好的绘制接口通过某些上层语言暴露出来，给游戏制作方使用。这些上层语言就叫做游戏脚本语言。
lua是脚本语言里面比较流行的一种，因其虚拟机小巧，API丰富、可灵活定制而深受游戏引擎开发商的喜爱。Unity使用了C#和Unity Script（现已废弃）来作为脚本语言。C#语言因为建立在.NET IL之上而具有跨平台扩展性。这样，游戏开发者只需要一套代码就可在多个平台运行。
<h5 align="center">
<img src="/assets/image/2018-1-30-unity_engine_and_csharp_script/pic_6.png">
</h5>

<h5 align="center">
图六：.NET CIL和CLR
</h5>

### 2.2 IL是什么？

IL(Intermediate Language，在.NET平台下是CIL，Common Intermediate Language)是一种中间语言格式。类似于Java的字节码（byte code）。这种格式的中间代码需要一个虚拟机来“解释”执行。IL的所有指令都是基于虚拟堆栈的：调用函数前，先将参数push到虚拟堆栈里面；函数执行的时候，从虚拟堆栈里面取出参数，然后将结果压入虚拟堆栈。由于调用方式简单，IL语言的指令集也比较精简。
IL作为脚本语言的独到之处在于可以将C#上层语言的各种特性（如泛型、协程等）转换成基本的IL指令集。然而这样的转换是有代价的，转换后的IL指令比普通的函数调用多出数倍。在游戏开发中，不宜在每一帧中进行这一类的调用。
另外，IL语言执行需要一个虚拟机翻译成目标平台的机器码，虽然.NET虚拟机已经比较高效了(可网上搜索.NET与Java的对比），但是和平台原生代码比起来，依然有一些差距。在iOS平台上，由于苹果禁止使用JIT方式，IL指令需要预先编译成目标平台库文件，然后在最终二进制文件打包的时候作为三方库链接进去。Unity游戏几乎所有的游戏逻辑都是通过脚本来实现的。一个大型游戏，成千上万个脚本，AOT方式打包造成的效率低下，是不得不考虑的问题。因此，Unity在5.3.4版本中引入了il2cpp技术。

### 2.3 il2cpp原理
顾名思义，il2cpp就是把中间语言转换成cpp代码的工具。上面我们讲到，在iOS平台上，由于无法使用JIT方式执行IL指令，所以需要先将游戏脚本打包成.NET Managed Assembly（这里的Managed是指二进制文件是在.NET层面打包的，可能会依赖.NET底层库，可以理解为“安全的”库文件。另外有些库文件是通过直接封装C/C++接口方式生成的，由于有如指针之类的底层内存操作，所以称作是Unmanaged Assembly。），然后和.NET CLR的Assembly链接之后生成最终的平台二进制文件。il2cpp的作用是去掉链接.NET CLR的步骤，将C#脚本生成的Managed Assembly“翻译”成C++文件，最后用目标平台的编译器编译这些C++文件来生成最终的游戏可执行文件。
<p align="center">
<img src="/assets/image/2018-1-30-unity_engine_and_csharp_script/pic_7.png">
</p>

<h5 align="center">
图七：il2cpp工作原理示意图
</h5>

il2cpp会先读取.NET二进制文件，解析其中的符号，然后将其中C#方法转换成对应的C方法。虽然名为il2cpp，但其实它只用到了很少部分的C++特性，绝大多数转换后的代码都是C函数。
<p align="center">
<img src="/assets/image/2018-1-30-unity_engine_and_csharp_script/pic_8.png">
</p>

<h5 align="center">
图八：il2cpp转换后的代码示例
</h5>
在游戏运行前，il2cpp会启动一个小的虚拟机，用于动态解析C方法。il2cpp将所有方法的签名放在一个叫做global-metadata.dat的文件里，方法调用的时候会先从此文件里读取C函数地址，然后再调用。获取函数指针的方法是这个：

```c++
inline Il2CppMethodPointer il2cpp_codegen_resolve_icall (const char* name)
{
    Il2CppMethodPointer method = il2cpp::vm::InternalCalls::Resolve (name);
    if (!method)
    {
        il2cpp::vm::Exception::Raise(il2cpp::vm::Exception::GetMissingMethodException(name));
    }
    return method;
}
```

Unity确保了所有采用il2cpp平台实现的游戏，其metadata的格式都是一样的。metadata加载时采用了内存映射技术，上述函数实际上会从一张内存的数据表里查找方法名对应的键值，也即目标函数的地址。

为何Unity要采用文件来记录方法名？一个原因是游戏有动态解析方法的需求；另一个原因是这样可以隐藏掉游戏内部逻辑的实现，起到一部分混淆的作用；最后还有一个重要的原因是Unity编辑器里可以设置脚本执行时候的延迟时间，而这些信息可以很方便的放在文件里。

Unity C#层面的接口暴露给游戏开发者，开发者通过C#脚本编写游戏逻辑，然后通过il2cpp将脚本翻译成C++文件，接着链接上Unity C#接口的底层C++实现，最终生成游戏的二进制文件，这就是Unity游戏开发的大致过程。按照Unity的说法，通过il2cpp方式打包有多种好处：1. 跨平台兼容性更好，基本上所有游戏平台都支持C++代码，而.NET/Mono运行时却不一定能在所有平台上运行；2. 效率更高，Unity给出的数据显示：采用il2cpp打包之后，游戏的执行效率提升了1.5到2.0倍。
